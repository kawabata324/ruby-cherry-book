# クラスの作成の仕方を学ぶ

# Rubyはオブジェクト指向言語で、これまでStringクラスやArrayクラスなどさまざまなクラスを使ってきました。
# しかし、クラスは使うだけでなく作ることも可能
# この章では自分のクラスを作る方法を説明していく

# 7-1-1
# この章の例題
# 改札機プログラム
#
#
# 改札機の機能
#
# 表 7-1
#
# 梅田
# 160  十三
# 190 　160　三国
#
#
# 3つの駅と運賃が決められている
#
# 改札機を通るためにはまず切符を購入する
# 購入可能な切符は160円と190円のみ
# 切符は入場時と出場時に改札機を通します
# 運賃が足りていれば出場できますが、不足している場合は出場できません
#
#
# テストシナリオ
#
# シナリオ１(1区間)
# 160円の切符を購入する
# 梅田で入場し十三で出場する
# 出場できる
#
# シナリオ２(2区間　運賃不足)
# 160円の切符を購入する
# 梅田で入場し、三国で出る
# 出場できない
#
# シナリオ３(2区間　運賃ちょうど)
# 190円の切符を購入する
# 梅田で入場し、三国で出る
# 出場できる
#
# シナリオ４(梅田以外の駅から乗車する)
# 160の切符を購入する
# 十三で入場し三国で出場する
# 出場できる
#
#
#
# 改札機プログラムの実行例
#
# 改札機オブジェクトの作成
# umeda = Gate.new(:umeda)
# mikuni = Gate.new(:mikuni)
#
# 160円の切符を購入して梅田で入場し三国で降りる
# ticket = Ticket.new(160)
# umeda.enter(ticket)
# mikuni.exit(ticket) => false
#
# 190円の切符を購入して梅田で入場し三国で降りる
# ticket = Ticket.new(190)
# umeda.enter(ticket)
# mikuni.exit(ticket) => true
#
#
#
#
# 7-12 この章で学ぶこと
#
# オブジェクト指向プログラミングの基礎
# クラスの定義
# selfキーワード
# クラスの継承
# メソッドの可視性
# 定数
# さまざまな種類の変数
# クラス定義やRubyの言語仕様に関する高度な話題
#
#
# 7-2　オブジェクト指向プログラミングの基礎知識
# 7-2-1
# クラスを使う場合と使わない場合
#
# クラスを使うプログラミングと使わないプログラミング
#
# userをあらわすデータをプログラム上で処理したい。ユーザはデータとして氏名(first_name last_name) 年齢を持ちます
# ハッシュと配列を使って
#
# users = []
# users << { first_name: 'Alice', last_name: 'Ruby', age: 20 }
# users << { first_name: 'Bob', last_name: 'Python', age: 30 }
#
# # 氏名を作成するメソッド
# def full_name(user)
#   "#{user[:first_name]} #{user[:last_name]}"
# end
#
# # userのデータを表示する
# users.each do |user|
#   puts "氏名：#{full_name(user)}, 年齢：#{user[:age]}"
# end
#
# # ハッシュを使った場合キーをタイプミスするとnilが返ってくる。間違ったキーを指定してもエラーにならない
# # nilが返ってきて不具合に気づきにくい
# pp users[0][:first_mame]
#
# # ハッシュは新しくキーを追加できたり、内容を簡単い変更できる脆くて壊れやすいプログラムになりがち
# # 勝手に新しいキーを追加する
# users[0][:country] = 'japan'
# # 勝手にfirst_nameを変更
# users[0][:first_name] = 'Carol'
# # ハッシュが変更される
# pp users[0]

# ここで示している小さなプログラムであれば問題ないかもしれない
# 大きなプログラムになれば、ハッシュで管理できなくなってくる
# そこで登場するのがクラスこういう場合はUserクラスという新しいデータ型を作りそこに入れた方がより堅牢なプログラムになる
#
# Userクラスを定義する
#
class User
  attr_reader :first_name, :last_name, :age

  def initialize(first_name, last_name, age)
    @first_name = first_name
    @last_name = last_name
    @age = age
  end

  # 氏名を作成するメソッド
  # クラス内部に定義することで引数を渡す必要がなくなる
  def full_name
    "#{first_name} #{last_name}"
  end
end

# ユーザのデータを作成する
users = []
users << User.new('Alice', 'Ruby', 20)
users << User.new('Bob', 'Python', 30)

# userのデータを表示する
users.each do |user|
  puts "氏名：#{user.full_name}, 年齢：#{user.age}"
end

# タイプミスした時にエラーが走るので気づきやすい
# users[0].first_mane
# 新しく属性を追加できない
# users[0].country = 'japan'
# 勝手にfirst_nameを書き換える
# users[0].first_name = 'Carol'
#
# クラスはこのように、内部にデータを保持しさらに自分が保持しているデータを利用する独自のメソッドを持つことだできます
# データとそのデータに関するメソッドが常にセットになるのでクラスを使わない場合に比べてデータとメソッドの整理がしやすくなります
# このサンプルプログラムは小さなプログラムのためそこまでメリットが見えないのかもしれないですが、プログラムが大規模になればなるほど
# データとメソッドを一緒に持ち運べるクラスのメリットが大きくなってきます

